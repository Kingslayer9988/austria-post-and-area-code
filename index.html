<!DOCTYPE html>
<html lang="de-AT">
<head>
    <title>Ortsvorwahlen und Postleitzahlen in Österreich</title>

    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="leaflet/leaflet.css">
    <script src="leaflet/leaflet.js"></script>
    <script src="leaflet/leaflet.ajax.min.js"></script>
    <script src="leaflet/leaflet-hash.js"></script>
    <script src="leaflet/leaflet.CenterCross-v0.0.8.js"></script>
    <!-- Add D3.js and jQuery libraries -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Our custom zone visualization script -->
    <script src="js/zone_map.js"></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #map {
            width: 100vw;
            height: 100%;
            z-index: 0;
        }

        .loader {
            border: 16px solid #f3f3f3; /* Light grey */
            border-top: 16px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 120px;
            height: 120px;
            animation: spin 2s linear infinite;
            z-index: 10;
            position: absolute;
            top: calc(50% - 60px);
            left: calc(50% - 60px);
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border: 1px solid #ccc;
        }

        .legend-label {
            font-size: 14px;
        }
  
        /* Info box styling */
        #info-box {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 1000;
        }

        /* Visualization control styling */
        #visualization-control {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }

        /* Map legend styling */
        #map-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
<div id="loader" class="loader"></div>
<div id='map'></div>
<div id="visualization-control">
    <label for="visualizationType">Visualization Type:</label>
    <select id="visualizationType" onchange="switchVisualization()">
        <option value="area">By Area Code</option>
        <option value="post">By Postal Code</option>
        <option value="zone">By Zone</option>
        <option value="gebiet">By Delivery Area (Liefergebiet)</option>
    </select>
</div>
<div id="map-legend" class="map-legend"></div>
<div id="info-box"></div>
<script>
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    const osm = L.tileLayer('https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    });

    const basemap = L.tileLayer('https://maps{s}.wien.gv.at/basemap/geolandbasemap/{type}/google3857/{z}/{y}/{x}.{format}', {
        maxZoom: 18,
        attribution: 'Datenquelle: <a href="https://www.basemap.at">basemap.at</a>',
        subdomains: ["", "1", "2", "3", "4"],
        type: 'normal',
        format: 'png',
        bounds: [[46.35877, 8.782379], [49.037872, 17.189532]]
    });

    const basemapOrtho = L.tileLayer('https://maps{s}.wien.gv.at/basemap/{type}/normal/google3857/{z}/{y}/{x}.{format}', {
        maxZoom: 18,
        attribution: 'Datenquelle: <a href="https://www.basemap.at">basemap.at</a>',
        subdomains: ["", "1", "2", "3", "4"],
        type: 'bmaporthofoto30cm',
        format: 'jpeg',
        bounds: [[46.35877, 8.782379], [49.037872, 17.189532]]
    });

    const map = L.map('map', {
        center: [47.5, 13.4],
        zoom: 8,
        layers: [osm]
    });
    map.doubleClickZoom.disable();


    const mapLayers = {
        "Open Street Map": osm,
        "Basemap.at": basemap,
        "Basemap.at Orthofoto": basemapOrtho,
    };

    const hash = new L.Hash(map);
    // const popUpPromises = [];

    function popUp(feature, layer) {
        // popUpPromises.push(new Promise((resolve, reject) => {
            const out = [];
            if (feature.hasOwnProperty('properties')) {
                for (const key in feature.properties) {
                    if (key === 'color') continue;
                    if (key === 'color1') continue;
                    if (key === 'plzcolor') continue;
                    if (key === 'plzcolor1') continue;
                    if (feature.properties.hasOwnProperty(key) && typeof feature.properties[key] == 'object' &&
                        feature.properties[key] !== null
                    ) {
                        let valStr = '';
                        if (Object.keys(feature.properties[key]).length > 1) {
                            valStr += '<ul>';
                            for (const val in feature.properties[key]) {
                                if (feature.properties[key].hasOwnProperty(val)) {
                                    valStr += '<li>';
                                    valStr += val + ': ' + feature.properties[key][val];
                                    valStr += '</li>';
                                }
                            }
                            valStr += '</ul>';
                        } else {
                            for (const val in feature.properties[key]) {
                                if (feature.properties[key].hasOwnProperty(val)) {
                                    valStr += val + ': ' + feature.properties[key][val];
                                }
                            }
                        }
                        if (key === 'iso') {
                            out.push("<b>GemKZ:</b> " + valStr);
                        } else {
                            out.push("<b>" + key + "</b>: " + valStr);
                        }
                    } else {
                        if (key === 'iso') {
                            out.push("<b>GemKZ</b>: " + feature.properties[key]);
                        } else {
                            out.push("<b>" + key + "</b>: " + feature.properties[key]);
                        }
                    }
                }
                layer.bindPopup(out.join("<br />"), {maxHeight: 300});
            }

            if (feature.hasOwnProperty('featureBounds')) {
                if (feature['featureBounds']['minX'] < minX) {
                    minX = feature['featureBounds']['minX'];
                }
                if (feature['featureBounds']['maxX'] > maxX) {
                    maxX = feature['featureBounds']['maxX'];
                }
                if (feature['featureBounds']['minY'] < minY) {
                    minY = feature['featureBounds']['minY'];
                }
                if (feature['featureBounds']['maxY'] > maxY) {
                    maxY = feature['featureBounds']['maxY'];
                }
            }
        // }))
    }

    const vorwahlLayer = new L.GeoJSON.AJAX("data/vorwahlen+plz.json",
        {
            onEachFeature: popUp,
            style: function (feature) {
                if (feature.properties.color === undefined) {
                    return {
                        'fillOpacity': 0,
                        'color': 'rgba(0,0,0,0)'
                    }
                } else {
                    return {
                        'color': feature.properties.color
                    }
                }
            }
        }
    );
    vorwahlLayer.getAttribution = function () {
        return 'RTR-GmbH – data.rtr.at';
    };
    vorwahlLayer.addEventListener('data:loaded', function () {
        console.log("Data loaded...");
        document.getElementById('loader').style.display = 'none';
    });
    vorwahlLayer.addTo(map);

    const plzLayer = new L.GeoJSON.AJAX("data/vorwahlen+plz.json",
        {
            onEachFeature: popUp,
            style: function (feature) {
                if (feature.properties['plzcolor'] === undefined) {
                    return {
                        'fillOpacity': 0,
                        'color': 'rgba(0,0,0,0)'
                    }
                } else {
                    return {
                        'color': feature.properties['plzcolor']
                    }
                }
            }
        }
    );
    plzLayer.getAttribution = function () {
        return 'RTR-GmbH – data.rtr.at';
    };
    plzLayer.addTo(map);

    // Promise.all(popUpPromises)
    //     .then(response => {
    //         console.log(response)
    //         console.log("popUpPromises: " + minX + "/" + minY + " - " + maxX + "/" + maxY);
    //         if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
    //             map.fitBounds([
    //                 [maxY, minX],
    //                 [minY, maxX]
    //             ]);
    //         }
    //     }
    // )



    if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
        map.fitBounds([
            [maxY, minX],
            [minY, maxX]
        ]);
    }

    const gemeindenLayer = new L.GeoJSON.AJAX("data/gemeinden_95_geo.json", {onEachFeature: popUp});
    const bezirkLayer = new L.GeoJSON.AJAX("data/bezirke_995_geo.json");
    const wienBezirkLayer = new L.GeoJSON.AJAX("data/BezirksgrenzenWien.json", {onEachFeature: popUp});

    const overlayLayers = {
        "Vorwahlen": vorwahlLayer,
        "Postleitzahlen": plzLayer,
        "Gemeinden": gemeindenLayer,
        "Bezirke": bezirkLayer,
        "Wiener Bezirke": wienBezirkLayer

    };

    const layerControl = L.control.layers(mapLayers, overlayLayers, {sortLayers: true}).addTo(map);

    function onLocationFound(e) {
        const radius = e.accuracy / 2;

        L.marker(e.latlng).addTo(map)
            .bindPopup("You are within " + radius + " meters from this point").openPopup();

        L.circle(e.latlng, radius).addTo(map);
    }

    function onLocationError(e) {
        alert(e.message);
    }

    map.on('locationfound', onLocationFound);
    map.on('locationerror', onLocationError);

    //	map.locate({setView: true, maxZoom: 16});

    function searchFunction(val) {
        minX = Infinity;
        minY = Infinity;
        maxX = -Infinity;
        maxY = -Infinity;
        console.log("Split: " , val.split(/[\s,;+]+/));
        const lowCaseVals = val.toLowerCase().split(/[\s,;+]+/);

        const promises = [];
        vorwahlLayer.eachLayer(function (layer) {
            promises.push(new Promise(function() {
                if ('vorwahl' in layer.feature.properties) {
                    let show = false;
                    let minLen = Infinity;
                    lowCaseVals.forEach((lowCaseVal) => {
                        if ('name' in layer.feature.properties && layer.feature.properties['name'].toLowerCase().startsWith(lowCaseVal)) {
                            show = true;
                        }
                        for (const vorwahl in layer.feature.properties['vorwahl']) {
                            if (vorwahl !== undefined && vorwahl.toString().toLowerCase().startsWith(lowCaseVal)) {
                                console.log("Vorwahl " + vorwahl + " found...");
                                show = true;
                                if (lowCaseVal.length < minLen) {
                                    minLen = lowCaseVal.length;
                                }
                                break;
                            }
                            if (
                                layer.feature.properties['vorwahl'].hasOwnProperty(vorwahl) &&
                                layer.feature.properties['vorwahl'][vorwahl].toString(10).toLowerCase().startsWith(lowCaseVal)
                            ) {
                                console.log("Vorwahl " + vorwahl + " for " + lowCaseVal + " found...");
                                show = true;
                                if (lowCaseVal.length < minLen) {
                                    minLen = lowCaseVal.length;
                                }
                                break;
                            }
                        }
                    })

                    if (show) {
                        if (minLen === 1) {
                            layer.setStyle({
                                'fillOpacity': 0.6,
                                'color': layer.feature.properties['color1']
                            });
                        } else {
                            layer.setStyle({
                                'fillOpacity': 0.6,
                                'color': layer.feature.properties['color']
                            });
                        }

                        if (layer.feature.hasOwnProperty('featureBounds')) {
                            if (layer.feature.featureBounds['minX'] < minX) {
                                minX = layer.feature.featureBounds['minX'];
                            }
                            if (layer.feature.featureBounds['maxX'] > maxX) {
                                maxX = layer.feature.featureBounds['maxX'];
                            }
                            if (layer.feature.featureBounds['minY'] < minY) {
                                minY = layer.feature.featureBounds['minY'];
                            }
                            if (layer.feature.featureBounds['maxY'] > maxY) {
                                maxY = layer.feature.featureBounds['maxY'];
                            }
                        }

                    } else {
                        layer.setStyle({
                            'fillOpacity': 0,
                            'color': 'rgba(0,0,0,0)'
                        });
                    }
                }
            }))
        });

        plzLayer.eachLayer(function (layer) {
            promises.push(new Promise(function () {
                if ('plz' in layer.feature.properties) {
                    let show = false;
                    lowCaseVals.forEach((lowCaseVal) => {
                        if ('name' in layer.feature.properties && layer.feature.properties['name'].toLowerCase().startsWith(lowCaseVal)) {
                            show = true;
                        }
                        for (const plz in layer.feature.properties['plz']) {
                            if (plz !== undefined && plz.toString(10).toLowerCase().startsWith(lowCaseVal)) {
                                console.log("PLZ " + plz + " found...");
                                show = true;
                                break;
                            }
                            if (
                                layer.feature.properties['plz'].hasOwnProperty(plz) &&
                                layer.feature.properties['plz'][plz].toString(10).toLowerCase().startsWith(lowCaseVal)
                            ) {
                                console.log("PLZ " + plz + " for " + lowCaseVal + " found...");
                                show = true;
                                break;
                            }
                        }
                    });

                    if (show) {
                        layer.setStyle({
                            'fillOpacity': 0.6,
                            'color': layer.feature.properties['plzcolor']
                        });

                        if (layer.feature.hasOwnProperty('featureBounds')) {
                            if (layer.feature.featureBounds['minX'] < minX) {
                                minX = layer.feature.featureBounds['minX'];
                            }
                            if (layer.feature.featureBounds['maxX'] > maxX) {
                                maxX = layer.feature.featureBounds['maxX'];
                            }
                            if (layer.feature.featureBounds['minY'] < minY) {
                                minY = layer.feature.featureBounds['minY'];
                            }
                            if (layer.feature.featureBounds['maxY'] > maxY) {
                                maxY = layer.feature.featureBounds['maxY'];
                            }
                        }
                    } else {
                        layer.setStyle({
                            'fillOpacity': 0,
                            'color': 'rgba(0,0,0,0)'
                        });
                    }
                }
            }));
        });

        setTimeout(function() {
            console.log("promises.len: " + promises.length)
            if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
                map.fitBounds([
                    [maxY, minX],
                    [minY, maxX]
                ]);
            }
        }, 500)

        Promise.all(promises)
            .then((response) => {
                console.log("promises: " + minX + "/" + minY + " - " + maxX + "/" + maxY);
                console.log(response)
                if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
                    map.fitBounds([
                        [maxY, minX],
                        [minY, maxX]
                    ]);
                }
            })
            .catch(error => console.log(`Error in executing ${error}`)) // Promise.all throws an error.
    }

    L.Control.textbox = L.Control.extend({
        onAdd: function () {
            const text = L.DomUtil.create('div');
            text.id = 'searchDiv';
            text.innerHTML = '<input id="searchInput" size=10 onkeyup="searchFunction(this.value)"/>';
            return text;
        },

        onRemove: function (map) {
        }
    });

    const textbox = function (opts) {
        return new L.Control.textbox(opts);
    };
    textbox({position: 'topleft'}).addTo(map);
	
    // Define Fake AreaMap and PostMap objects to make the existing code work
    const AreaMap = {
        initAreaMap: function() {
            console.log("Area Map Selected");
            // Show the existing vorwahl layer
            map.addLayer(vorwahlLayer);
            map.removeLayer(plzLayer);
        }
    };
    
    const PostMap = {
        initPostMap: function() {
            console.log("Post Map Selected");
            // Show the existing plz layer
            map.addLayer(plzLayer);
            map.removeLayer(vorwahlLayer);
        }
    };
    
    // Function to switch between visualization types
    function switchVisualization() {
        const vizType = document.getElementById('visualizationType').value;
        
        console.log("Selected visualization type:", vizType);
        
        // Remove all layers first
        map.removeLayer(vorwahlLayer);
        map.removeLayer(plzLayer);
        
        // Initialize the selected visualization
        if (vizType === 'area') {
            // Use the existing area code visualization
            AreaMap.initAreaMap();
        } else if (vizType === 'post') {
            // Use the existing postal code visualization
            PostMap.initPostMap();
        } else if (vizType === 'zone') {
            // Use our new zone visualization
            ZoneMap.setMode('zone');
            ZoneMap.initZoneMap();
        } else if (vizType === 'gebiet') {
            // Use our new delivery area visualization
            ZoneMap.setMode('gebiet');
            ZoneMap.initZoneMap();
        }
    }
    
    // Initialize the page
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize the default visualization (area code map)
        document.getElementById('visualizationType').value = 'area';
        
        // Add hover effects for postal codes if needed
        // This would need to be implemented in a way that works with the GeoJSON layers
    });
</script>
</body>
</html>
