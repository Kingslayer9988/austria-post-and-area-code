<!DOCTYPE html>
<html lang="de-AT">
<head>
    <title>Liefergebietszuordnung für Dispatcher</title>

    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="leaflet/leaflet.css">
    <script src="leaflet/leaflet.js"></script>
    <script src="leaflet/leaflet.ajax.min.js"></script>
    <script src="leaflet/leaflet-hash.js"></script>
    <script src="leaflet/leaflet.CenterCross-v0.0.8.js"></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        #map {
            width: 100vw;
            height: 100%;
            z-index: 0;
        }

        .loader {
            border: 16px solid #f3f3f3;
            border-top: 16px solid #3498db;
            border-radius: 50%;
            width: 120px;
            height: 120px;
            animation: spin 2s linear infinite;
            z-index: 10;
            position: absolute;
            top: calc(50% - 60px);
            left: calc(50% - 60px);
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .info {
            padding: 6px 8px;
            font: 14px/16px Arial, Helvetica, sans-serif;
            background: white;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 5px;
        }
        
        .info h4 {
            margin: 0 0 5px;
            color: #777;
        }
        
        .legend {
            text-align: left;
            line-height: 18px;
            color: #555;
        }
        
        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }
        
        .search-control {
            background: white;
            padding: 5px;
            border-radius: 4px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
        }
        
        .search-control input {
            width: 100%;
            border: 1px solid #ccc;
            border-radius: 2px;
            padding: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
<div id="loader" class="loader"></div>
<div id='map'></div>

<script>
    // Define the delivery zones based on your screenshot
    const deliveryZones = {
        'Gebiet 1': {
            zones: ['A', 'B', 'C', 'E'],
            color: '#87CEFA',  // Light blue
            description: 'Gebiet 1 (A, B, C, E)'
        },
        'Gebiet 2': {
            zones: ['H', 'D'],
            color: '#E6CCF2',  // Light purple/pink
            description: 'Gebiet 2 (H, D)'
        },
        'Gebiet 3': {
            zones: ['F'],
            color: '#9370DB',  // Darker purple
            description: 'Gebiet 3 (F)'
        },
        'Gebiet 4': {
            zones: ['G'],
            color: '#FFFF99',  // Yellow
            description: 'Gebiet 4 (G)'
        },
        'Gebiet 5': {
            zones: ['I'],
            color: '#FFA07A',  // Red/orange
            description: 'Gebiet 5 (I)'
        },
        'Gebiet 6': {
            zones: ['J'],
            color: '#90EE90',  // Light green
            description: 'Gebiet 6 (J)'
        }
    };
    
    // Function to get color based on zone letter
    function getColorForZone(zone) {
        for (const gebiet in deliveryZones) {
            if (deliveryZones[gebiet].zones.includes(zone)) {
                return deliveryZones[gebiet].color;
            }
        }
        return '#CCCCCC'; // Default gray color
    }
    
    // Function to get gebiet name based on zone letter
    function getGebietForZone(zone) {
        for (const gebiet in deliveryZones) {
            if (deliveryZones[gebiet].zones.includes(zone)) {
                return gebiet;
            }
        }
        return 'Unbekannt';
    }

    // Function to add zone information based on postal code or location name
    function addZoneInformation(geoJsonData) {
        // Define specific postal code or location mappings to zones
        // This is a simplified approach - you may need to adjust based on your actual data
        const zoneAssignments = {
            // Key locations
            locations: {
                'neudörfl': 'A',
                'waidhofen': 'C',
                'eferding': 'D'
                // Add more specific locations as needed
            },
            // Postal code prefixes
            postalPrefixes: {
                '1': 'A',  // Vienna
                '2': 'A',  // Lower Austria (east)
                '30': 'C', // Lower Austria (north)
                '31': 'C', // Lower Austria (north)
                '32': 'C', // Lower Austria (north)
                '33': 'B', // Lower Austria (northeast)
                '34': 'B', // Lower Austria (northeast)
                '35': 'B', // Lower Austria (northeast)
                '36': 'B', // Lower Austria (northeast)
                '37': 'B', // Lower Austria (northeast)
                '38': 'B', // Lower Austria (northeast)
                '39': 'B', // Lower Austria (northeast)
                '4': 'D',  // Upper Austria
                '50': 'H', // Salzburg
                '51': 'H', // Salzburg
                '52': 'H', // Salzburg
                '53': 'H', // Salzburg
                '54': 'H', // Salzburg
                '55': 'H', // Salzburg
                '56': 'H', // Salzburg
                '57': 'H', // Salzburg
                '58': 'H', // Salzburg
                '59': 'H', // Salzburg
                '6': 'I',  // Tyrol
                '67': 'J', // Vorarlberg
                '68': 'J', // Vorarlberg
                '69': 'J', // Vorarlberg
                '7': 'F',  // Burgenland
                '8': 'F',  // Styria
                '9': 'G'   // Carinthia
            }
        };

        // Process each feature in the GeoJSON
        if (geoJsonData && geoJsonData.features) {
            geoJsonData.features.forEach(feature => {
                if (feature.properties) {
                    let assignedZone = null;
                    
                    // Try to find zone by location name
                    if (feature.properties.name) {
                        const name = feature.properties.name.toLowerCase();
                        for (const [locationKey, zoneValue] of Object.entries(zoneAssignments.locations)) {
                            if (name.includes(locationKey)) {
                                assignedZone = zoneValue;
                                break;
                            }
                        }
                    }
                    
                    // If no zone assigned by name, try postal code
                    if (!assignedZone && feature.properties.plz) {
                        // Get the first postal code if multiple exist
                        const plzKeys = Object.keys(feature.properties.plz);
                        if (plzKeys.length > 0) {
                            const firstPlz = plzKeys[0];
                            // Try matching by postal code prefix
                            for (const [prefix, zoneValue] of Object.entries(zoneAssignments.postalPrefixes)) {
                                if (firstPlz.startsWith(prefix)) {
                                    assignedZone = zoneValue;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Override with specific zone mappings (from your screenshot)
                    // These should match the locations shown in your screenshot exactly
                    if (feature.properties.name) {
                        const name = feature.properties.name.toLowerCase();
                        // Add exact overrides from your screenshot
                        if (name === 'neudörfl') {
                            assignedZone = 'A';
                        } else if (name === 'waidhofen') {
                            assignedZone = 'C';
                        } else if (name === 'eferding') {
                            assignedZone = 'D';
                        }
                    }
                    
                    // Assign the zone if one was determined
                    if (assignedZone) {
                        feature.properties.zone = assignedZone;
                    }
                }
            });
        }
        
        return geoJsonData;
    }

    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    const osm = L.tileLayer('https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    });

    const basemap = L.tileLayer('https://maps{s}.wien.gv.at/basemap/geolandbasemap/{type}/google3857/{z}/{y}/{x}.{format}', {
        maxZoom: 18,
        attribution: 'Datenquelle: <a href="https://www.basemap.at">basemap.at</a>',
        subdomains: ["", "1", "2", "3", "4"],
        type: 'normal',
        format: 'png',
        bounds: [[46.35877, 8.782379], [49.037872, 17.189532]]
    });

    const basemapOrtho = L.tileLayer('https://maps{s}.wien.gv.at/basemap/{type}/normal/google3857/{z}/{y}/{x}.{format}', {
        maxZoom: 18,
        attribution: 'Datenquelle: <a href="https://www.basemap.at">basemap.at</a>',
        subdomains: ["", "1", "2", "3", "4"],
        type: 'bmaporthofoto30cm',
        format: 'jpeg',
        bounds: [[46.35877, 8.782379], [49.037872, 17.189532]]
    });

    const map = L.map('map', {
        center: [47.5, 13.4],
        zoom: 8,
        layers: [osm]
    });
    map.doubleClickZoom.disable();

    const mapLayers = {
        "Open Street Map": osm,
        "Basemap.at": basemap,
        "Basemap.at Orthofoto": basemapOrtho,
    };

    const hash = new L.Hash(map);

    // Function to create popups with zone information
    function popUp(feature, layer) {
        const out = [];
        if (feature.hasOwnProperty('properties')) {
            // Add delivery zone info to the popup if available
            if (feature.properties.zone) {
                const gebiet = getGebietForZone(feature.properties.zone);
                out.push("<b>Zone:</b> " + feature.properties.zone);
                out.push("<b>Liefergebiet:</b> " + gebiet);
            }
            
            // Add other properties
            for (const key in feature.properties) {
                if (key === 'color' || key === 'color1' || key === 'plzcolor' || 
                    key === 'plzcolor1' || key === 'zone') continue;
                
                if (feature.properties.hasOwnProperty(key) && typeof feature.properties[key] == 'object' &&
                    feature.properties[key] !== null
                ) {
                    let valStr = '';
                    if (Object.keys(feature.properties[key]).length > 1) {
                        valStr += '<ul>';
                        for (const val in feature.properties[key]) {
                            if (feature.properties[key].hasOwnProperty(val)) {
                                valStr += '<li>';
                                valStr += val + ': ' + feature.properties[key][val];
                                valStr += '</li>';
                            }
                        }
                        valStr += '</ul>';
                    } else {
                        for (const val in feature.properties[key]) {
                            if (feature.properties[key].hasOwnProperty(val)) {
                                valStr += val + ': ' + feature.properties[key][val];
                            }
                        }
                    }
                    if (key === 'iso') {
                        out.push("<b>GemKZ:</b> " + valStr);
                    } else {
                        out.push("<b>" + key + "</b>: " + valStr);
                    }
                } else {
                    if (key === 'iso') {
                        out.push("<b>GemKZ</b>: " + feature.properties[key]);
                    } else {
                        out.push("<b>" + key + "</b>: " + feature.properties[key]);
                    }
                }
            }
            layer.bindPopup(out.join("<br />"), {maxHeight: 300});
        }

        if (feature.hasOwnProperty('featureBounds')) {
            if (feature['featureBounds']['minX'] < minX) {
                minX = feature['featureBounds']['minX'];
            }
            if (feature['featureBounds']['maxX'] > maxX) {
                maxX = feature['featureBounds']['maxX'];
            }
            if (feature['featureBounds']['minY'] < minY) {
                minY = feature['featureBounds']['minY'];
            }
            if (feature['featureBounds']['maxY'] > maxY) {
                maxY = feature['featureBounds']['maxY'];
            }
        }
    }

    // Function to add legend
    function addLegend() {
        const legend = L.control({position: 'bottomright'});
        
        legend.onAdd = function(map) {
            const div = L.DomUtil.create('div', 'info legend');
            let labels = ['<strong>Liefergebiete</strong>'];
            
            // Add legend items for each delivery zone
            for(const gebiet in deliveryZones) {
                labels.push(
                    '<i style="background:' + deliveryZones[gebiet].color + '"></i> ' +
                    deliveryZones[gebiet].description
                );
            }
            
            div.innerHTML = labels.join('<br>');
            return div;
        };
        
        legend.addTo(map);
    }

    // Override L.GeoJSON.AJAX to process the data before rendering
    const originalAJAX = L.GeoJSON.AJAX;
    L.GeoJSON.AJAX = function(url, options) {
        const originalOptions = options || {};
        
        // Create a new options object with a modified data processor
        const newOptions = { ...originalOptions };
        
        // Store the original "data loaded" callback
        const originalOnDataLoaded = newOptions.onEachFeature;
        
        // Add a preprocessor function to assign zones to features
        newOptions.middleware = function(data) {
            // Modify the data to add zone information
            return addZoneInformation(data);
        };
        
        // Create instance with new options
        return new originalAJAX(url, newOptions);
    };

    // Create delivery zone layer
    const liefergebieteLayer = new L.GeoJSON.AJAX("data/vorwahlen+plz.json", {
        onEachFeature: popUp,
        style: function(feature) {
            if (feature.properties.zone) {
                return {
                    'fillOpacity': 0.6,
                    'weight': 1,
                    'color': '#333',
                    'fillColor': getColorForZone(feature.properties.zone)
                };
            } else {
                return {
                    'fillOpacity': 0,
                    'color': 'rgba(0,0,0,0)'
                };
            }
        }
    });
    
    liefergebieteLayer.getAttribution = function() {
        return 'RTR-GmbH – data.rtr.at | Liefergebiete angepasst';
    };
    
    liefergebieteLayer.addEventListener('data:loaded', function() {
        console.log("Data loaded...");
        document.getElementById('loader').style.display = 'none';
        // After data is loaded, add the legend
        addLegend();
    });
    
    liefergebieteLayer.addTo(map);

    const plzLayer = new L.GeoJSON.AJAX("data/vorwahlen+plz.json", {
        onEachFeature: popUp,
        style: function(feature) {
            if (feature.properties['plzcolor'] === undefined) {
                return {
                    'fillOpacity': 0,
                    'color': 'rgba(0,0,0,0)'
                };
            } else {
                return {
                    'color': feature.properties['plzcolor']
                };
            }
        }
    });
    
    plzLayer.getAttribution = function() {
        return 'RTR-GmbH – data.rtr.at';
    };

    if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
        map.fitBounds([
            [maxY, minX],
            [minY, maxX]
        ]);
    }

    const gemeindenLayer = new L.GeoJSON.AJAX("data/gemeinden_95_geo.json", {onEachFeature: popUp});
    const bezirkLayer = new L.GeoJSON.AJAX("data/bezirke_995_geo.json");
    const wienBezirkLayer = new L.GeoJSON.AJAX("data/BezirksgrenzenWien.json", {onEachFeature: popUp});

    const overlayLayers = {
        "Liefergebiete": liefergebieteLayer,
        "Postleitzahlen": plzLayer,
        "Gemeinden": gemeindenLayer,
        "Bezirke": bezirkLayer,
        "Wiener Bezirke": wienBezirkLayer
    };

    const layerControl = L.control.layers(mapLayers, overlayLayers, {sortLayers: true}).addTo(map);

    function onLocationFound(e) {
        const radius = e.accuracy / 2;

        L.marker(e.latlng).addTo(map)
            .bindPopup("You are within " + radius + " meters from this point").openPopup();

        L.circle(e.latlng, radius).addTo(map);
    }

    function onLocationError(e) {
        alert(e.message);
    }

    map.on('locationfound', onLocationFound);
    map.on('locationerror', onLocationError);

    function searchFunction(val) {
        minX = Infinity;
        minY = Infinity;
        maxX = -Infinity;
        maxY = -Infinity;
        
        console.log("Split: ", val.split(/[\s,;+]+/));
        const lowCaseVals = val.toLowerCase().split(/[\s,;+]+/);

        const promises = [];
        
        // Search in delivery zones
        liefergebieteLayer.eachLayer(function(layer) {
            promises.push(new Promise(function() {
                let show = false;
                
                // Check if any search term matches zone or gebiet
                lowCaseVals.forEach((lowCaseVal) => {
                    // Match by zone name
                    if (layer.feature.properties.zone && 
                        layer.feature.properties.zone.toLowerCase() === lowCaseVal) {
                        show = true;
                    }
                    
                    // Match by gebiet number (1-6)
                    const gebietNum = getGebietForZone(layer.feature.properties.zone).replace('Gebiet ', '');
                    if (gebietNum === lowCaseVal) {
                        show = true;
                    }
                    
                    // Match by place name
                    if ('name' in layer.feature.properties && 
                        layer.feature.properties['name'].toLowerCase().startsWith(lowCaseVal)) {
                        show = true;
                    }
                    
                    // Match by vorwahl
                    if ('vorwahl' in layer.feature.properties) {
                        for (const vorwahl in layer.feature.properties['vorwahl']) {
                            if (vorwahl !== undefined && vorwahl.toString().toLowerCase().startsWith(lowCaseVal)) {
                                console.log("Vorwahl " + vorwahl + " found...");
                                show = true;
                                break;
                            }
                            if (
                                layer.feature.properties['vorwahl'].hasOwnProperty(vorwahl) &&
                                layer.feature.properties['vorwahl'][vorwahl].toString(10).toLowerCase().startsWith(lowCaseVal)
                            ) {
                                console.log("Vorwahl " + vorwahl + " for " + lowCaseVal + " found...");
                                show = true;
                                break;
                            }
                        }
                    }
                });

                if (show) {
                    layer.setStyle({
                        'fillOpacity': 0.8,
                        'weight': 2,
                        'color': '#000',
                        'fillColor': getColorForZone(layer.feature.properties.zone)
                    });

                    if (layer.feature.hasOwnProperty('featureBounds')) {
                        if (layer.feature.featureBounds['minX'] < minX) {
                            minX = layer.feature.featureBounds['minX'];
                        }
                        if (layer.feature.featureBounds['maxY'] > maxY) {
                                maxY = layer.feature.featureBounds['maxY'];
                            }
                        }
                    } else {
                        layer.setStyle({
                            'fillOpacity': 0,
                            'color': 'rgba(0,0,0,0)'
                        });
                    }
                }
            }));
        });

        setTimeout(function() {
            console.log("promises.len: " + promises.length);
            if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
                map.fitBounds([
                    [maxY, minX],
                    [minY, maxX]
                ]);
            }
        }, 500);

        Promise.all(promises)
            .then((response) => {
                console.log("promises: " + minX + "/" + minY + " - " + maxX + "/" + maxY);
                if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
                    map.fitBounds([
                        [maxY, minX],
                        [minY, maxX]
                    ]);
                }
            })
            .catch(error => console.log(`Error in executing ${error}`));
    }

    // Create a better search control
    L.Control.Search = L.Control.extend({
        onAdd: function(map) {
            const container = L.DomUtil.create('div', 'search-control');
            const input = L.DomUtil.create('input', '', container);
            
            input.type = 'text';
            input.placeholder = 'Suche nach PLZ, Ort, Zone oder Gebiet...';
            input.id = 'searchInput';
            
            L.DomEvent.on(input, 'keyup', function(e) {
                searchFunction(this.value);
            });
            
            L.DomEvent.disableClickPropagation(container);
            
            return container;
        }
    });
    
    new L.Control.Search({ position: 'topleft' }).addTo(map);
</script>

</body>
</html>X'] > maxX) {
                            maxX = layer.feature.featureBounds['maxX'];
                        }
                        if (layer.feature.featureBounds['minY'] < minY) {
                            minY = layer.feature.featureBounds['minY'];
                        }
                        if (layer.feature.featureBounds['maxY'] > maxY) {
                            maxY = layer.feature.featureBounds['maxY'];
                        }
                    }
                } else {
                    layer.setStyle({
                        'fillOpacity': 0.2,
                        'color': '#888',
                        'weight': 0.5
                    });
                }
            }));
        });

        // Search in PLZ layer
        plzLayer.eachLayer(function(layer) {
            promises.push(new Promise(function() {
                if ('plz' in layer.feature.properties) {
                    let show = false;
                    lowCaseVals.forEach((lowCaseVal) => {
                        if ('name' in layer.feature.properties && 
                            layer.feature.properties['name'].toLowerCase().startsWith(lowCaseVal)) {
                            show = true;
                        }
                        for (const plz in layer.feature.properties['plz']) {
                            if (plz !== undefined && plz.toString(10).toLowerCase().startsWith(lowCaseVal)) {
                                console.log("PLZ " + plz + " found...");
                                show = true;
                                break;
                            }
                            if (
                                layer.feature.properties['plz'].hasOwnProperty(plz) &&
                                layer.feature.properties['plz'][plz].toString(10).toLowerCase().startsWith(lowCaseVal)
                            ) {
                                console.log("PLZ " + plz + " for " + lowCaseVal + " found...");
                                show = true;
                                break;
                            }
                        }
                    });

                    if (show) {
                        layer.setStyle({
                            'fillOpacity': 0.6,
                            'color': layer.feature.properties['plzcolor'],
                            'weight': 2
                        });

                        if (layer.feature.hasOwnProperty('featureBounds')) {
                            if (layer.feature.featureBounds['minX'] < minX) {
                                minX = layer.feature.featureBounds['minX'];
                            }
                            if (layer.feature.featureBounds['maxX'] > maxX) {
                                maxX = layer.feature.featureBounds['maxX'];
                            }
                            if (layer.feature.featureBounds['minY'] < minY) {
                                minY = layer.feature.featureBounds['minY'];
                            }
                            if (layer.feature.featureBounds['max

    // Promise.all(popUpPromises)
    //     .then(response => {
    //         console.log(response)
    //         console.log("popUpPromises: " + minX + "/" + minY + " - " + maxX + "/" + maxY);
    //         if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
    //             map.fitBounds([
    //                 [maxY, minX],
    //                 [minY, maxX]
    //             ]);
    //         }
    //     }
    // )



    if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
        map.fitBounds([
            [maxY, minX],
            [minY, maxX]
        ]);
    }

    const gemeindenLayer = new L.GeoJSON.AJAX("data/gemeinden_95_geo.json", {onEachFeature: popUp});
    const bezirkLayer = new L.GeoJSON.AJAX("data/bezirke_995_geo.json");
    const wienBezirkLayer = new L.GeoJSON.AJAX("data/BezirksgrenzenWien.json", {onEachFeature: popUp});

    const overlayLayers = {
        "Vorwahlen": vorwahlLayer,
        "Postleitzahlen": plzLayer,
        "Gemeinden": gemeindenLayer,
        "Bezirke": bezirkLayer,
        "Wiener Bezirke": wienBezirkLayer

    };

    const layerControl = L.control.layers(mapLayers, overlayLayers, {sortLayers: true}).addTo(map);

    function onLocationFound(e) {
        const radius = e.accuracy / 2;

        L.marker(e.latlng).addTo(map)
            .bindPopup("You are within " + radius + " meters from this point").openPopup();

        L.circle(e.latlng, radius).addTo(map);
    }

    function onLocationError(e) {
        alert(e.message);
    }

    map.on('locationfound', onLocationFound);
    map.on('locationerror', onLocationError);

    //	map.locate({setView: true, maxZoom: 16});

    function searchFunction(val) {
        minX = Infinity;
        minY = Infinity;
        maxX = -Infinity;
        maxY = -Infinity;
        console.log("Split: " , val.split(/[\s,;+]+/));
        const lowCaseVals = val.toLowerCase().split(/[\s,;+]+/);

        const promises = [];
        vorwahlLayer.eachLayer(function (layer) {
            promises.push(new Promise(function() {
                if ('vorwahl' in layer.feature.properties) {
                    let show = false;
                    let minLen = Infinity;
                    lowCaseVals.forEach((lowCaseVal) => {
                        if ('name' in layer.feature.properties && layer.feature.properties['name'].toLowerCase().startsWith(lowCaseVal)) {
                            show = true;
                        }
                        for (const vorwahl in layer.feature.properties['vorwahl']) {
                            if (vorwahl !== undefined && vorwahl.toString().toLowerCase().startsWith(lowCaseVal)) {
                                console.log("Vorwahl " + vorwahl + " found...");
                                show = true;
                                if (lowCaseVal.length < minLen) {
                                    minLen = lowCaseVal.length;
                                }
                                break;
                            }
                            if (
                                layer.feature.properties['vorwahl'].hasOwnProperty(vorwahl) &&
                                layer.feature.properties['vorwahl'][vorwahl].toString(10).toLowerCase().startsWith(lowCaseVal)
                            ) {
                                console.log("Vorwahl " + vorwahl + " for " + lowCaseVal + " found...");
                                show = true;
                                if (lowCaseVal.length < minLen) {
                                    minLen = lowCaseVal.length;
                                }
                                break;
                            }
                        }
                    })

                    if (show) {
                        if (minLen === 1) {
                            layer.setStyle({
                                'fillOpacity': 0.6,
                                'color': layer.feature.properties['color1']
                            });
                        } else {
                            layer.setStyle({
                                'fillOpacity': 0.6,
                                'color': layer.feature.properties['color']
                            });
                        }

                        if (layer.feature.hasOwnProperty('featureBounds')) {
                            if (layer.feature.featureBounds['minX'] < minX) {
                                minX = layer.feature.featureBounds['minX'];
                            }
                            if (layer.feature.featureBounds['maxX'] > maxX) {
                                maxX = layer.feature.featureBounds['maxX'];
                            }
                            if (layer.feature.featureBounds['minY'] < minY) {
                                minY = layer.feature.featureBounds['minY'];
                            }
                            if (layer.feature.featureBounds['maxY'] > maxY) {
                                maxY = layer.feature.featureBounds['maxY'];
                            }
                        }

                    } else {
                        layer.setStyle({
                            'fillOpacity': 0,
                            'color': 'rgba(0,0,0,0)'
                        });
                    }
                }
            }))
        });

        plzLayer.eachLayer(function (layer) {
            promises.push(new Promise(function () {
                if ('plz' in layer.feature.properties) {
                    let show = false;
                    lowCaseVals.forEach((lowCaseVal) => {
                        if ('name' in layer.feature.properties && layer.feature.properties['name'].toLowerCase().startsWith(lowCaseVal)) {
                            show = true;
                        }
                        for (const plz in layer.feature.properties['plz']) {
                            if (plz !== undefined && plz.toString(10).toLowerCase().startsWith(lowCaseVal)) {
                                console.log("PLZ " + plz + " found...");
                                show = true;
                                break;
                            }
                            if (
                                layer.feature.properties['plz'].hasOwnProperty(plz) &&
                                layer.feature.properties['plz'][plz].toString(10).toLowerCase().startsWith(lowCaseVal)
                            ) {
                                console.log("PLZ " + plz + " for " + lowCaseVal + " found...");
                                show = true;
                                break;
                            }
                        }
                    });

                    if (show) {
                        layer.setStyle({
                            'fillOpacity': 0.6,
                            'color': layer.feature.properties['plzcolor']
                        });

                        if (layer.feature.hasOwnProperty('featureBounds')) {
                            if (layer.feature.featureBounds['minX'] < minX) {
                                minX = layer.feature.featureBounds['minX'];
                            }
                            if (layer.feature.featureBounds['maxX'] > maxX) {
                                maxX = layer.feature.featureBounds['maxX'];
                            }
                            if (layer.feature.featureBounds['minY'] < minY) {
                                minY = layer.feature.featureBounds['minY'];
                            }
                            if (layer.feature.featureBounds['maxY'] > maxY) {
                                maxY = layer.feature.featureBounds['maxY'];
                            }
                        }
                    } else {
                        layer.setStyle({
                            'fillOpacity': 0,
                            'color': 'rgba(0,0,0,0)'
                        });
                    }
                }
            }));
        });

        setTimeout(function() {
            console.log("promises.len: " + promises.length)
            if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
                map.fitBounds([
                    [maxY, minX],
                    [minY, maxX]
                ]);
            }
        }, 500)

        Promise.all(promises)
            .then((response) => {
                console.log("promises: " + minX + "/" + minY + " - " + maxX + "/" + maxY);
                console.log(response)
                if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
                    map.fitBounds([
                        [maxY, minX],
                        [minY, maxX]
                    ]);
                }
            })
            .catch(error => console.log(`Error in executing ${error}`)) // Promise.all throws an error.
    }

    L.Control.textbox = L.Control.extend({
        onAdd: function () {
            const text = L.DomUtil.create('div');
            text.id = 'searchDiv';
            text.innerHTML = '<input id="searchInput" size=10 onkeyup="searchFunction(this.value)"/>';
            return text;
        },

        onRemove: function (map) {
        }
    });

    const textbox = function (opts) {
        return new L.Control.textbox(opts);
    };
    textbox({position: 'topleft'}).addTo(map);

</script>


</body>
</html>
