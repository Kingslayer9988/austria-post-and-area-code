<!DOCTYPE html>
<html lang="de-AT">
<head>
    <title>Liefergebietszuordnung für Dispatcher</title>

    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="leaflet/leaflet.css">
    <script src="leaflet/leaflet.js"></script>
    <script src="leaflet/leaflet.ajax.min.js"></script>
    <script src="leaflet/leaflet-hash.js"></script>
    <script src="leaflet/leaflet.CenterCross-v0.0.8.js"></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        #map {
            width: 100vw;
            height: 100%;
            z-index: 0;
        }

        .loader {
            border: 16px solid #f3f3f3;
            border-top: 16px solid #3498db;
            border-radius: 50%;
            width: 120px;
            height: 120px;
            animation: spin 2s linear infinite;
            z-index: 10;
            position: absolute;
            top: calc(50% - 60px);
            left: calc(50% - 60px);
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .info {
            padding: 6px 8px;
            font: 14px/16px Arial, Helvetica, sans-serif;
            background: white;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 5px;
        }
        
        .legend {
            text-align: left;
            line-height: 18px;
            color: #555;
        }
        
        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
<div id="loader" class="loader"></div>
<div id='map'></div>

<script>
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    // Define the delivery zones
    const deliveryZones = {
        'Gebiet 1': {
            color: '#87CEFA',  // Light blue
            description: 'Gebiet 1 (A, B, C, E)'
        },
        'Gebiet 2': {
            color: '#E6CCF2',  // Light purple/pink
            description: 'Gebiet 2 (H, D)'
        },
        'Gebiet 3': {
            color: '#9370DB',  // Darker purple
            description: 'Gebiet 3 (F)'
        },
        'Gebiet 4': {
            color: '#FFFF99',  // Yellow
            description: 'Gebiet 4 (G)'
        },
        'Gebiet 5': {
            color: '#FFA07A',  // Red/orange
            description: 'Gebiet 5 (I)'
        },
        'Gebiet 6': {
            color: '#90EE90',  // Light green
            description: 'Gebiet 6 (J)'
        }
    };

    const osm = L.tileLayer('https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    });

    const basemap = L.tileLayer('https://maps{s}.wien.gv.at/basemap/geolandbasemap/{type}/google3857/{z}/{y}/{x}.{format}', {
        maxZoom: 18,
        attribution: 'Datenquelle: <a href="https://www.basemap.at">basemap.at</a>',
        subdomains: ["", "1", "2", "3", "4"],
        type: 'normal',
        format: 'png',
        bounds: [[46.35877, 8.782379], [49.037872, 17.189532]]
    });

    const basemapOrtho = L.tileLayer('https://maps{s}.wien.gv.at/basemap/{type}/normal/google3857/{z}/{y}/{x}.{format}', {
        maxZoom: 18,
        attribution: 'Datenquelle: <a href="https://www.basemap.at">basemap.at</a>',
        subdomains: ["", "1", "2", "3", "4"],
        type: 'bmaporthofoto30cm',
        format: 'jpeg',
        bounds: [[46.35877, 8.782379], [49.037872, 17.189532]]
    });

    const map = L.map('map', {
        center: [47.5, 13.4],
        zoom: 8,
        layers: [osm]
    });
    map.doubleClickZoom.disable();

    const mapLayers = {
        "Open Street Map": osm,
        "Basemap.at": basemap,
        "Basemap.at Orthofoto": basemapOrtho,
    };

    const hash = new L.Hash(map);

    function popUp(feature, layer) {
        const out = [];
        if (feature.hasOwnProperty('properties')) {
            // Determine which delivery area this feature belongs to based on coordinates
            // This is a simplified approach - you'll need to adjust based on your actual map regions
            const gebiet = determineGebietByLocation(feature);
            if (gebiet) {
                out.push("<b>Liefergebiet:</b> " + gebiet);
            }
            
            for (const key in feature.properties) {
                if (key === 'color' || key === 'color1' || key === 'plzcolor' || key === 'plzcolor1') continue;
                
                if (feature.properties.hasOwnProperty(key) && typeof feature.properties[key] == 'object' &&
                    feature.properties[key] !== null
                ) {
                    let valStr = '';
                    if (Object.keys(feature.properties[key]).length > 1) {
                        valStr += '<ul>';
                        for (const val in feature.properties[key]) {
                            if (feature.properties[key].hasOwnProperty(val)) {
                                valStr += '<li>';
                                valStr += val + ': ' + feature.properties[key][val];
                                valStr += '</li>';
                            }
                        }
                        valStr += '</ul>';
                    } else {
                        for (const val in feature.properties[key]) {
                            if (feature.properties[key].hasOwnProperty(val)) {
                                valStr += val + ': ' + feature.properties[key][val];
                            }
                        }
                    }
                    if (key === 'iso') {
                        out.push("<b>GemKZ:</b> " + valStr);
                    } else {
                        out.push("<b>" + key + "</b>: " + valStr);
                    }
                } else {
                    if (key === 'iso') {
                        out.push("<b>GemKZ</b>: " + feature.properties[key]);
                    } else {
                        out.push("<b>" + key + "</b>: " + feature.properties[key]);
                    }
                }
            }
            layer.bindPopup(out.join("<br />"), {maxHeight: 300});
        }

        if (feature.hasOwnProperty('featureBounds')) {
            if (feature['featureBounds']['minX'] < minX) {
                minX = feature['featureBounds']['minX'];
            }
            if (feature['featureBounds']['maxX'] > maxX) {
                maxX = feature['featureBounds']['maxX'];
            }
            if (feature['featureBounds']['minY'] < minY) {
                minY = feature['featureBounds']['minY'];
            }
            if (feature['featureBounds']['maxY'] > maxY) {
                maxY = feature['featureBounds']['maxY'];
            }
        }
    }

    // Function to determine which gebiet a feature belongs to based on location or properties
    function determineGebietByLocation(feature) {
        // This is where you would implement your logic to determine the delivery area
        // For now, this is a placeholder - you'll need to adjust based on your specific requirements
        
        // Example approach: use bounding boxes for each region
        if (!feature.geometry || !feature.geometry.coordinates) return null;
        
        // Get center point of feature (simplified)
        let center;
        if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
            const bounds = L.geoJSON(feature).getBounds();
            center = bounds.getCenter();
        } else {
            return null;
        }
        
        // Simple zone determination based on lat/lng
        // These are rough approximations - you'll need to adjust based on your actual zones
        
        // Eastern Austria (Vienna, Lower Austria east, northern Burgenland)
        if (center.lng > 15.5 && center.lat > 47.5) {
            return 'Gebiet 1'; // A, B, C, E
        }
        
        // Central North (Upper Austria, parts of Lower Austria)
        if (center.lng < 15.5 && center.lng > 13.0 && center.lat > 48.0) {
            return 'Gebiet 2'; // H, D
        }
        
        // Southeastern (Styria, southern Burgenland)
        if (center.lng > 14.5 && center.lat < 47.5 && center.lat > 46.5) {
            return 'Gebiet 3'; // F
        }
        
        // Southern (Carinthia)
        if (center.lat < 47.0 && center.lng > 13.0 && center.lng < 15.0) {
            return 'Gebiet 4'; // G
        }
        
        // Western (Tyrol)
        if (center.lng < 13.0 && center.lng > 10.5) {
            return 'Gebiet 5'; // I
        }
        
        // Westernmost (Vorarlberg)
        if (center.lng < 10.5) {
            return 'Gebiet 6'; // J
        }
        
        return null;
    }

    // Function to get color based on gebiet
    function getColorForGebiet(gebiet) {
        return deliveryZones[gebiet]?.color || '#CCCCCC';
    }

    // Add legend
    function addLegend() {
        const legend = L.control({position: 'bottomright'});
        
        legend.onAdd = function(map) {
            const div = L.DomUtil.create('div', 'info legend');
            let labels = ['<strong>Liefergebiete</strong>'];
            
            for(const gebiet in deliveryZones) {
                labels.push(
                    '<i style="background:' + deliveryZones[gebiet].color + '"></i> ' +
                    deliveryZones[gebiet].description
                );
            }
            
            div.innerHTML = labels.join('<br>');
            return div;
        };
        
        legend.addTo(map);
    }

    // Create delivery zone layer
    const vorwahlLayer = new L.GeoJSON.AJAX("data/vorwahlen+plz.json", {
        onEachFeature: popUp,
        style: function(feature) {
            const gebiet = determineGebietByLocation(feature);
            if (gebiet) {
                return {
                    'fillOpacity': 0.6,
                    'weight': 1,
                    'color': '#333',
                    'fillColor': getColorForGebiet(gebiet)
                };
            } else {
                return {
                    'fillOpacity': 0,
                    'color': 'rgba(0,0,0,0)'
                };
            }
        }
    });
    
    vorwahlLayer.getAttribution = function() {
        return 'RTR-GmbH – data.rtr.at | Liefergebiete angepasst';
    };
    
    vorwahlLayer.addEventListener('data:loaded', function() {
        console.log("Data loaded...");
        document.getElementById('loader').style.display = 'none';
        // Add legend after data is loaded
        addLegend();
    });
    
    vorwahlLayer.addTo(map);

    const plzLayer = new L.GeoJSON.AJAX("data/vorwahlen+plz.json", {
        onEachFeature: popUp,
        style: function(feature) {
            if (feature.properties['plzcolor'] === undefined) {
                return {
                    'fillOpacity': 0,
                    'color': 'rgba(0,0,0,0)'
                };
            } else {
                return {
                    'color': feature.properties['plzcolor']
                };
            }
        }
    });
    
    plzLayer.getAttribution = function() {
        return 'RTR-GmbH – data.rtr.at';
    };

    if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
        map.fitBounds([
            [maxY, minX],
            [minY, maxX]
        ]);
    }

    const gemeindenLayer = new L.GeoJSON.AJAX("data/gemeinden_95_geo.json", {onEachFeature: popUp});
    const bezirkLayer = new L.GeoJSON.AJAX("data/bezirke_995_geo.json");
    const wienBezirkLayer = new L.GeoJSON.AJAX("data/BezirksgrenzenWien.json", {onEachFeature: popUp});

    const overlayLayers = {
        "Liefergebiete": vorwahlLayer,
        "Postleitzahlen": plzLayer,
        "Gemeinden": gemeindenLayer,
        "Bezirke": bezirkLayer,
        "Wiener Bezirke": wienBezirkLayer
    };

    const layerControl = L.control.layers(mapLayers, overlayLayers, {sortLayers: true}).addTo(map);

    function onLocationFound(e) {
        const radius = e.accuracy / 2;
        L.marker(e.latlng).addTo(map)
            .bindPopup("You are within " + radius + " meters from this point").openPopup();
        L.circle(e.latlng, radius).addTo(map);
    }

    function onLocationError(e) {
        alert(e.message);
    }

    map.on('locationfound', onLocationFound);
    map.on('locationerror', onLocationError);

    function searchFunction(val) {
        // Original search function implementation
        // ...
    }

    L.Control.textbox = L.Control.extend({
        onAdd: function() {
            const text = L.DomUtil.create('div');
            text.id = 'searchDiv';
            text.innerHTML = '<input id="searchInput" size=10 placeholder="Suche..." onkeyup="searchFunction(this.value)"/>';
            return text;
        },
        onRemove: function(map) {}
    });

    const textbox = function(opts) {
        return new L.Control.textbox(opts);
    };
    textbox({position: 'topleft'}).addTo(map);
</script>

</body>
</html>
