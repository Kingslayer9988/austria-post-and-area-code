<!DOCTYPE html>
<html lang="de-AT">
<head>
    <title>Liefergebietszuordnung für Dispatcher</title>

    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="leaflet/leaflet.css">
    <script src="leaflet/leaflet.js"></script>
    <script src="leaflet/leaflet.ajax.min.js"></script>
    <script src="leaflet/leaflet-hash.js"></script>
    <script src="leaflet/leaflet.CenterCross-v0.0.8.js"></script>


    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #map {
            width: 100vw;
            height: 100%;
            z-index: 0;
        }

        .loader {
            border: 16px solid #f3f3f3; /* Light grey */
            border-top: 16px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 120px;
            height: 120px;
            animation: spin 2s linear infinite;
            z-index: 10;
            position: absolute;
            top: calc(50% - 60px);
            left: calc(50% - 60px);
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .info {
            padding: 6px 8px;
            font: 14px/16px Arial, Helvetica, sans-serif;
            background: white;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 5px;
        }
        
        .legend {
            text-align: left;
            line-height: 18px;
            color: #555;
        }
        
        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }
        
        #searchInput {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            width: 180px;
        }

    </style>
</head>
<body>
<div id="loader" class="loader"></div>
<div id='map'></div>

<script>
    // Define the delivery zones based on your screenshot - adjusted colors to match screenshot
    const deliveryZones = {
        '1': {
            id: 'Gebiet 1',
            zones: ['A', 'B', 'C', 'E'],
            color: '#ADD8E6',  // Light blue
            description: 'Gebiet 1 (A, B, C, E)'
        },
        '2': {
            id: 'Gebiet 2',
            zones: ['H', 'D'],
            color: '#E6CCF2',  // Light purple/pink
            description: 'Gebiet 2 (H, D)'
        },
        '3': {
            id: 'Gebiet 3',
            zones: ['F'],
            color: '#9370DB',  // Darker purple
            description: 'Gebiet 3 (F)'
        },
        '4': {
            id: 'Gebiet 4',
            zones: ['G'],
            color: '#FFFF99',  // Yellow
            description: 'Gebiet 4 (G)'
        },
        '5': {
            id: 'Gebiet 5',
            zones: ['I'],
            color: '#FFA07A',  // Red/orange
            description: 'Gebiet 5 (I)'
        },
        '6': {
            id: 'Gebiet 6',
            zones: ['J'],
            color: '#90EE90',  // Light green
            description: 'Gebiet 6 (J)'
        }
    };
    
    // Define zone to postal code area mapping based on provinces in Austria
    const zonePostalMapping = {
        'A': [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], // Vienna, parts of Lower Austria - first digits of postal codes
        'B': [2], // Northeast Lower Austria
        'C': [3], // Northwest Lower Austria
        'D': [4], // Upper Austria
        'E': [5], // Salzburg and parts of Lower Austria
        'F': [8], // Styria
        'G': [9], // Carinthia 
        'H': [4, 5], // Upper Austria parts and parts of Salzburg
        'I': [6], // Tyrol
        'J': [67, 68, 69] // Vorarlberg - these are specific postal code prefixes
    };
    
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    const osm = L.tileLayer('https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    });

    const basemap = L.tileLayer('https://maps{s}.wien.gv.at/basemap/geolandbasemap/{type}/google3857/{z}/{y}/{x}.{format}', {
        maxZoom: 18,
        attribution: 'Datenquelle: <a href="https://www.basemap.at">basemap.at</a>',
        subdomains: ["", "1", "2", "3", "4"],
        type: 'normal',
        format: 'png',
        bounds: [[46.35877, 8.782379], [49.037872, 17.189532]]
    });

    const basemapOrtho = L.tileLayer('https://maps{s}.wien.gv.at/basemap/{type}/normal/google3857/{z}/{y}/{x}.{format}', {
        maxZoom: 18,
        attribution: 'Datenquelle: <a href="https://www.basemap.at">basemap.at</a>',
        subdomains: ["", "1", "2", "3", "4"],
        type: 'bmaporthofoto30cm',
        format: 'jpeg',
        bounds: [[46.35877, 8.782379], [49.037872, 17.189532]]
    });

    const map = L.map('map', {
        center: [47.5, 13.4],
        zoom: 8,
        layers: [osm]
    });
    map.doubleClickZoom.disable();


    const mapLayers = {
        "Open Street Map": osm,
        "Basemap.at": basemap,
        "Basemap.at Orthofoto": basemapOrtho,
    };

    const hash = new L.Hash(map);

    // Function to determine zone from the feature data
    function getZoneFromFeature(feature) {
        if (!feature || !feature.properties) return null;
        
        // Try to determine by first digit of postal code if available
        if (feature.properties.plz) {
            const firstPlz = Object.keys(feature.properties.plz)[0];
            if (firstPlz) {
                const plzPrefix = firstPlz.substring(0, 2);
                for (const [zone, prefixes] of Object.entries(zonePostalMapping)) {
                    for (const prefix of prefixes) {
                        const prefixStr = prefix.toString();
                        if (plzPrefix.startsWith(prefixStr)) {
                            return zone;
                        }
                    }
                }
            }
        }
        
        // If we can't determine by postal code, try existing color method
        if (feature.properties.color) {
            const colorPrefix = feature.properties.color.substring(1, 2);
            if (/^[A-Ja-j]$/.test(colorPrefix)) {
                return colorPrefix.toUpperCase();
            }
        }
        
        return null;
    }
    
    // Function to get the delivery area number from a zone letter
    function getGebietFromZone(zone) {
        for (const [gebietNum, gebietData] of Object.entries(deliveryZones)) {
            if (gebietData.zones.includes(zone)) {
                return gebietNum;
            }
        }
        return null;
    }
    
    // Function to get color based on zone letter
    function getColorForZone(zone) {
        const gebietNum = getGebietFromZone(zone);
        if (gebietNum && deliveryZones[gebietNum]) {
            return deliveryZones[gebietNum].color;
        }
        return '#CCCCCC'; // Default gray color
    }
    
    function popUp(feature, layer) {
        const out = [];
        if (feature.hasOwnProperty('properties')) {
            // Add delivery zone info if possible
            const zone = getZoneFromFeature(feature);
            if (zone) {
                const gebietNum = getGebietFromZone(zone);
                if (gebietNum) {
                    out.push("<b>Zone:</b> " + zone);
                    out.push("<b>Liefergebiet:</b> " + deliveryZones[gebietNum].id);
                }
            }
            
            for (const key in feature.properties) {
                if (key === 'color') continue;
                if (key === 'color1') continue;
                if (key === 'plzcolor') continue;
                if (key === 'plzcolor1') continue;
                if (feature.properties.hasOwnProperty(key) && typeof feature.properties[key] == 'object' &&
                    feature.properties[key] !== null
                ) {
                    let valStr = '';
                    if (Object.keys(feature.properties[key]).length > 1) {
                        valStr += '<ul>';
                        for (const val in feature.properties[key]) {
                            if (feature.properties[key].hasOwnProperty(val)) {
                                valStr += '<li>';
                                valStr += val + ': ' + feature.properties[key][val];
                                valStr += '</li>';
                            }
                        }
                        valStr += '</ul>';
                    } else {
                        for (const val in feature.properties[key]) {
                            if (feature.properties[key].hasOwnProperty(val)) {
                                valStr += val + ': ' + feature.properties[key][val];
                            }
                        }
                    }
                    if (key === 'iso') {
                        out.push("<b>GemKZ:</b> " + valStr);
                    } else {
                        out.push("<b>" + key + "</b>: " + valStr);
                    }
                } else {
                    if (key === 'iso') {
                        out.push("<b>GemKZ</b>: " + feature.properties[key]);
                    } else {
                        out.push("<b>" + key + "</b>: " + feature.properties[key]);
                    }
                }
            }
            layer.bindPopup(out.join("<br />"), {maxHeight: 300});
        }

        if (feature.hasOwnProperty('featureBounds')) {
            if (feature['featureBounds']['minX'] < minX) {
                minX = feature['featureBounds']['minX'];
            }
            if (feature['featureBounds']['maxX'] > maxX) {
                maxX = feature['featureBounds']['maxX'];
            }
            if (feature['featureBounds']['minY'] < minY) {
                minY = feature['featureBounds']['minY'];
            }
            if (feature['featureBounds']['maxY'] > maxY) {
                maxY = feature['featureBounds']['maxY'];
            }
        }
    }
    
    // Add a legend to the map
    function addLegend() {
        const legend = L.control({position: 'bottomright'});
        
        legend.onAdd = function(map) {
            const div = L.DomUtil.create('div', 'info legend');
            let labels = ['<strong>Liefergebiete</strong>'];
            
            // Add legend items for each delivery zone
            for(const [gebietNum, gebietData] of Object.entries(deliveryZones)) {
                labels.push(
                    '<i style="background:' + gebietData.color + '"></i> ' +
                    gebietData.description
                );
            }
            
            div.innerHTML = labels.join('<br>');
            return div;
        };
        
        legend.addTo(map);
    }

    const vorwahlLayer = new L.GeoJSON.AJAX("data/vorwahlen+plz.json",
        {
            onEachFeature: popUp,
            style: function (feature) {
                const zone = getZoneFromFeature(feature);
                if (zone) {
                    // If we have a zone, use delivery zone colors with enhanced borders
                    return {
                        'fillOpacity': 0.7,
                        'weight': 1.5,
                        'color': '#333',
                        'fillColor': getColorForZone(zone)
                    }
                } else if (feature.properties.color === undefined) {
                    return {
                        'fillOpacity': 0,
                        'color': 'rgba(0,0,0,0)'
                    }
                } else {
                    return {
                        'color': feature.properties.color,
                        'fillOpacity': 0.5
                    }
                }
            }
        }
    );
    vorwahlLayer.getAttribution = function () {
        return 'RTR-GmbH – data.rtr.at | Liefergebiete angepasst';
    };
    vorwahlLayer.addEventListener('data:loaded', function () {
        console.log("Data loaded...");
        document.getElementById('loader').style.display = 'none';
        // Add legend after data is loaded
        addLegend();
    });
    vorwahlLayer.addTo(map);

    const plzLayer = new L.GeoJSON.AJAX("data/vorwahlen+plz.json",
        {
            onEachFeature: popUp,
            style: function (feature) {
                if (feature.properties['plzcolor'] === undefined) {
                    return {
                        'fillOpacity': 0,
                        'color': 'rgba(0,0,0,0)'
                    }
                } else {
                    return {
                        'color': feature.properties['plzcolor']
                    }
                }
            }
        }
    );
    plzLayer.getAttribution = function () {
        return 'RTR-GmbH – data.rtr.at';
    };

    if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
        map.fitBounds([
            [maxY, minX],
            [minY, maxX]
        ]);
    }

    const gemeindenLayer = new L.GeoJSON.AJAX("data/gemeinden_95_geo.json", {onEachFeature: popUp});
    const bezirkLayer = new L.GeoJSON.AJAX("data/bezirke_995_geo.json");
    const wienBezirkLayer = new L.GeoJSON.AJAX("data/BezirksgrenzenWien.json", {onEachFeature: popUp});

    const overlayLayers = {
        "Liefergebiete": vorwahlLayer,
        "Postleitzahlen": plzLayer,
        "Gemeinden": gemeindenLayer,
        "Bezirke": bezirkLayer,
        "Wiener Bezirke": wienBezirkLayer

    };

    const layerControl = L.control.layers(mapLayers, overlayLayers, {sortLayers: true}).addTo(map);

    function onLocationFound(e) {
        const radius = e.accuracy / 2;

        L.marker(e.latlng).addTo(map)
            .bindPopup("You are within " + radius + " meters from this point").openPopup();

        L.circle(e.latlng, radius).addTo(map);
    }

    function onLocationError(e) {
        alert(e.message);
    }

    map.on('locationfound', onLocationFound);
    map.on('locationerror', onLocationError);

    function searchFunction(val) {
        minX = Infinity;
        minY = Infinity;
        maxX = -Infinity;
        maxY = -Infinity;
        console.log("Split: ", val.split(/[\s,;+]+/));
        const lowCaseVals = val.toLowerCase().split(/[\s,;+]+/);

        const promises = [];
        vorwahlLayer.eachLayer(function (layer) {
            promises.push(new Promise(function() {
                if ('vorwahl' in layer.feature.properties) {
                    let show = false;
                    let minLen = Infinity;
                    
                    // Check for direct zone or gebiet search
                    const zone = getZoneFromFeature(layer.feature);
                    if (zone) {
                        const gebietNum = getGebietFromZone(zone);
                        // Check if any search term matches zone letter
                        if (lowCaseVals.includes(zone.toLowerCase())) {
                            show = true;
                        }
                        // Check if any search term matches gebiet number
                        if (gebietNum && lowCaseVals.includes(gebietNum)) {
                            show = true;
                        }
                    }
                    
                    // Original search logic
                    lowCaseVals.forEach((lowCaseVal) => {
                        if ('name' in layer.feature.properties && layer.feature.properties['name'].toLowerCase().startsWith(lowCaseVal)) {
                            show = true;
                        }
                        for (const vorwahl in layer.feature.properties['vorwahl']) {
                            if (vorwahl !== undefined && vorwahl.toString().toLowerCase().startsWith(lowCaseVal)) {
                                console.log("Vorwahl " + vorwahl + " found...");
                                show = true;
                                if (lowCaseVal.length < minLen) {
                                    minLen = lowCaseVal.length;
                                }
                                break;
                            }
                            if (
                                layer.feature.properties['vorwahl'].hasOwnProperty(vorwahl) &&
                                layer.feature.properties['vorwahl'][vorwahl].toString(10).toLowerCase().startsWith(lowCaseVal)
                            ) {
                                console.log("Vorwahl " + vorwahl + " for " + lowCaseVal + " found...");
                                show = true;
                                if (lowCaseVal.length < minLen) {
                                    minLen = lowCaseVal.length;
                                }
                                break;
                            }
                        }
                    });

                    if (show) {
                        const zone = getZoneFromFeature(layer.feature);
                        
                        if (zone) {
                            // Use delivery zone color if available
                            layer.setStyle({
                                'fillOpacity': 0.8,
                                'weight': 2,
                                'color': '#000',
                                'fillColor': getColorForZone(zone)
                            });
                        } else if (minLen === 1) {
                            layer.setStyle({
                                'fillOpacity': 0.6,
                                'color': layer.feature.properties['color1']
                            });
                        } else {
                            layer.setStyle({
                                'fillOpacity': 0.6,
                                'color': layer.feature.properties['color']
                            });
                        }

                        if (layer.feature.hasOwnProperty('featureBounds')) {
                            if (layer.feature.featureBounds['minX'] < minX) {
                                minX = layer.feature.featureBounds['minX'];
                            }
                            if (layer.feature.featureBounds['maxX'] > maxX) {
                                maxX = layer.feature.featureBounds['maxX'];
                            }
                            if (layer.feature.featureBounds['minY'] < minY) {
                                minY = layer.feature.featureBounds['minY'];
                            }
                            if (layer.feature.featureBounds['maxY'] > maxY) {
                                maxY = layer.feature.featureBounds['maxY'];
                            }
                        }

                    } else {
                        layer.setStyle({
                            'fillOpacity': 0,
                            'color': 'rgba(0,0,0,0)'
                        });
                    }
                }
            }));
        });

        plzLayer.eachLayer(function (layer) {
            promises.push(new Promise(function () {
                if ('plz' in layer.feature.properties) {
                    let show = false;
                    lowCaseVals.forEach((lowCaseVal) => {
                        if ('name' in layer.feature.properties && layer.feature.properties['name'].toLowerCase().startsWith(lowCaseVal)) {
                            show = true;
                        }
                        for (const plz in layer.feature.properties['plz']) {
                            if (plz !== undefined && plz.toString(10).toLowerCase().startsWith(lowCaseVal)) {
                                console.log("PLZ " + plz + " found...");
                                show = true;
                                break;
                            }
                            if (
                                layer.feature.properties['plz'].hasOwnProperty(plz) &&
                                layer.feature.properties['plz'][plz].toString(10).toLowerCase().startsWith(lowCaseVal)
                            ) {
                                console.log("PLZ " + plz + " for " + lowCaseVal + " found...");
                                show = true;
                                break;
                            }
                        }
                    });

                    if (show) {
                        layer.setStyle({
                            'fillOpacity': 0.6,
                            'color': layer.feature.properties['plzcolor']
                        });

                        if (layer.feature.hasOwnProperty('featureBounds')) {
                            if (layer.feature.featureBounds['minX'] < minX) {
                                minX = layer.feature.featureBounds['minX'];
                            }
                            if (layer.feature.featureBounds['maxX'] > maxX) {
                                maxX = layer.feature.featureBounds['maxX'];
                            }
                            if (layer.feature.featureBounds['minY'] < minY) {
                                minY = layer.feature.featureBounds['minY'];
                            }
                            if (layer.feature.featureBounds['maxY'] > maxY) {
                                maxY = layer.feature.featureBounds['maxY'];
                            }
                        }
                    } else {
                        layer.setStyle({
                            'fillOpacity': 0,
                            'color': 'rgba(0,0,0,0)'
                        });
                    }
                }
            }));
        });

        setTimeout(function() {
            console.log("promises.len: " + promises.length);
            if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
                map.fitBounds([
                    [maxY, minX],
                    [minY, maxX]
                ]);
            }
        }, 500);

        Promise.all(promises)
            .then((response) => {
                console.log("promises: " + minX + "/" + minY + " - " + maxX + "/" + maxY);
                console.log(response);
                if (minX < Infinity && maxX > -Infinity && minY < Infinity && maxY > -Infinity) {
                    map.fitBounds([
                        [maxY, minX],
                        [minY, maxX]
                    ]);
                }
            })
            .catch(error => console.log(`Error in executing ${error}`)); // Promise.all throws an error.
    }

    L.Control.textbox = L.Control.extend({
        onAdd: function () {
            const text = L.DomUtil.create('div');
            text.id = 'searchDiv';
            text.innerHTML = '<input id="searchInput" placeholder="Suche nach Zone, Gebiet oder PLZ..." onkeyup="searchFunction(this.value)"/>';
            return text;
        },

        onRemove: function (map) {
        }
    });

    const textbox = function (opts) {
        return new L.Control.textbox(opts);
    };
    textbox({position: 'topleft'}).addTo(map);

</script>

</body>
</html>
